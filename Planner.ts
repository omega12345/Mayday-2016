///<reference path="World.ts"/>
///<reference path="Interpreter.ts"/>
///<reference path="Graph.ts"/>
/** 
* Planner module
*
* The goal of the Planner module is to take the interpetation(s)
* produced by the Interpreter module and to plan a sequence of actions
* for the robot to put the world into a state compatible with the
* user's command, i.e. to achieve what the user wanted.
*
* The planner should use your A* search implementation to find a plan.
*/
module Planner {

    //////////////////////////////////////////////////////////////////////
    // exported functions, classes and interfaces/types

    /**
     * Top-level driver for the Planner. Calls `planInterpretation` for each given interpretation generated by the Interpreter. 
     * @param interpretations List of possible interpretations.
     * @param currentState The current state of the world.
     * @returns Augments Interpreter.InterpretationResult with a plan represented by a list of strings.
     */
    export function plan(interpretations : Interpreter.InterpretationResult[], currentState : WorldState) : PlannerResult[] {
        var errors : Error[] = [];
        var plans : PlannerResult[] = [];
        interpretations.forEach((interpretation) => {
            try {
                var result : PlannerResult = <PlannerResult>interpretation;
                result.plan = planInterpretation(result.interpretation, currentState);
                if (result.plan.length == 0) {
                    result.plan.push("That is already true!");
                }
                plans.push(result);
            } catch(err) {
                errors.push(err);
            }
        });

        if (plans.length) {
            return plans;
        } else {
            // only throw the first error found
            throw errors[0];
        }
    }

    export interface PlannerResult extends Interpreter.InterpretationResult {
        plan : string[];
    }

    export function stringify(result : PlannerResult) : string {
        return result.plan.join(", ");
    }

    //////////////////////////////////////////////////////////////////////
    // private functions

    /**
     * The core planner function. The code here is just a template;
     * you should rewrite this function entirely. In this template,
     * the code produces a dummy plan which is not connected to the
     * argument `interpretation`, but your version of the function
     * should be such that the resulting plan depends on
     * `interpretation`.
     *
     * 
     * @param interpretation The logical interpretation of the user's desired goal. The plan needs to be such that by executing it, the world is put into a state that satisfies this goal.
     * @param state The current world state.
     * @returns Basically, a plan is a
     * stack of strings, which are either system utterances that
     * explain what the robot is doing (e.g. "Moving left") or actual
     * actions for the robot to perform, encoded as "l", "r", "p", or
     * "d". The code shows how to build a plan. Each step of the plan can
     * be added using the `push` method.
     */
    function planInterpretation(interpretation : Interpreter.DNFFormula, state : WorldState) : string[] {
        // This function returns a dummy plan involving a random stack
        var plan : string[] = [];
        //A DNFFormula is a list of lists.
        //A goal state must satisfy all requirements of at least one of these lists.
        var isGoal = (n:WorldState)=>
            {for (var i = 0; i<interpretation.length;i++){
                //reset adheres for each conjunction
                var adheres:boolean = true;
                for (var j = 0; j<interpretation[i].length;j++){
                    var int : Interpreter.Literal = interpretation[i][j];
                    if (!literalIsTheCase(n, int)) adheres = false;
                }
                if (adheres) return adheres;
            };
            return false;}
        var heuristic = (n:WorldState)=>
            {   if (!interpretation.length) return 0;
                var minToDo = 0;
                for (var j = 0; j<interpretation[0].length;j++){
                    var int : Interpreter.Literal = interpretation[0][j];
                    if (!literalIsTheCase(n, int)) minToDo++;
                }
                
                for (var i = 0; i<interpretation.length;i++){
                var toDoHere = 0;
                for (var j = 0; j<interpretation[i].length;j++){
                    var int : Interpreter.Literal = interpretation[i][j];
                    if (!literalIsTheCase(n, int)) toDoHere++;
                }
                minToDo = Math.min (minToDo, toDoHere);
            };
            return minToDo;}
        
        var searchResult : SearchResult<WorldState> 
            = aStarSearch<WorldState>(new myGraph,
                                      state,
                                      isGoal,
                                      heuristic,
                                      10); 
        //now take the search result and turn it into a set of moves
        //plan.push("Found the following result:" + searchResult);
        var noLefts: number = 0;
        var noRights: number = 0;
        for (var i = 0; i<searchResult.path.length-1; i++){
            var graph: myGraph = new myGraph;
            var edges: AnnotatedEdge[] = graph.outgoingEdges(searchResult.path[i]);
            
            for (var edge = 0; edge<edges.length; edge++){
                if (graph.compareNodes(edges[edge].to, searchResult.path[i+1])==0){
                    plan.push(edges[edge].action);
                    switch (edges[edge].action){
                        case "p": if (noLefts>0){
                                    plan.push("Moving " + noLefts + " steps left");
                                    noLefts = 0;
                                  }
                                  if (noRights>0){
                                    plan.push("Moving " + noRights + " steps left");
                                    noRights = 0;
                                  }
                                  plan.push ("Picking up the " + describeConcisely(edges[edge].to.holding, edges[edge].from));
                                  break;
                        case "d":if (noLefts>0){
                                    plan.push("Moving " + noLefts + " steps left");
                                    noLefts = 0;
                                  }
                                  if (noRights>0){
                                    plan.push("Moving " + noRights + " steps left");
                                    noRights = 0;
                                  }
                                  plan.push ("Putting down the " + describeConcisely(edges[edge].from.holding, edges[edge].to));
                                  break;
                        case "l": noLefts++;
                                  break;
                        case "r": noRights++;
                                  break;
                        default: plan.push("Found strange action: " + edges[edge].action);
                                break;
                    }
                }
            }
        }
        return plan;
    }

    function literalIsTheCase (n:WorldState, int : Interpreter.Literal):boolean{
        var adheres = true;
        if(int.relation == "holding"){
            if ((n.holding!==int.args[0] && int.polarity)||
                (n.holding ==int.args[0] && !int.polarity))
                    adheres=false;
        } else
            adheres = Interpreter.isTrueRelation(int.args[0], int.args[1], int.relation, n);
        return adheres;
    }
    
    class myGraph implements Graph<WorldState>{
        outgoingEdges(node:WorldState): AnnotatedEdge[]{
            var result: AnnotatedEdge[]=[];
            //there can be at most four edges; one for each action l, r, p, d.
            //for each action, calculate whether the action is permissible;
            //if so, add edge.
            //if we are not at the leftmost point, we can move left
            if (node.arm){
                var nextNode: WorldState = copyWorld(node);
                nextNode.arm-=1;
                result.push({action:"l", from:node, to:nextNode, cost:1});
            }
            //if we are not at the rightmost point, we can move right
            if (node.arm<node.stacks.length-1){
                var nextNode: WorldState = copyWorld(node);
                nextNode.arm+=1;
                result.push({action:"r", from:node, to:nextNode, cost:1});
            }
            //now if we can drop something we plainly can't pick up anything and vice versa
            if (node.holding!=null){
                var nextNode: WorldState = copyWorld(node);
                var support: string;
                if (node.stacks[node.arm].length)
                    support = node.stacks[node.arm][node.stacks[node.arm].length-1];
                else
                    support = "floor";
                if (support == "floor" || Interpreter.isOkSupport(node.objects[node.holding], node.objects[support])) {
                    nextNode.stacks[nextNode.arm].push(nextNode.holding);
                    nextNode.holding=null;
                    result.push({action:"d", from:node, to:nextNode, cost:1});
                }
            }
            else if (node.stacks[node.arm].length) {
                var nextNode: WorldState = copyWorld(node);
                nextNode.holding = nextNode.stacks[nextNode.arm].pop();
                result.push({action:"p", from:node, to:nextNode, cost:1});
            }
            return result;
        }
        compareNodes : collections.ICompareFunction<WorldState> = 
            function (a: WorldState, b: WorldState): number{
                for (var i = 0; i<a.stacks.length; i++){
                    for (var j = 0; j<a.stacks[i].length; j++){
                        if (a.stacks[i][j]!==b.stacks[i][j])
                            return 1;
                    }
                }
                if (a.holding!==b.holding) return 1;
                if (a.arm!==b.arm) return 1;
                return 0;
            };
    }
    
    class AnnotatedEdge extends Edge<WorldState>{
        action: string;
    }
    //deep copy function
    function copyWorld(world:WorldState):WorldState{
        var s:Stack[]=[];
        for (var i = 0; i<world.stacks.length; i++){
            var stack:Stack=[];
            for (var j = 0; j<world.stacks[i].length; j++){
                stack.push(world.stacks[i][j]);
            }
            s.push(stack);
        }
        return {
            stacks:s,
            holding:world.holding,
            arm:world.arm,
            objects:world.objects,
            examples:world.examples
        };
    }

    //finds the most concise description of an object in the world.
    //Assumes that no objects are being held.
    export function describeConcisely(object:string, world:WorldState):string{
        //all the objects.
        var objects: string[] = Array.prototype.concat.apply([], world.stacks);
        var thisObject = world.objects[object];
        var allObjects : ObjectDefinition[] = [];
        for (var i = 0; i<objects.length; i++){
                allObjects.push(world.objects[objects[i]]);
        }
        return describeInContext(thisObject, allObjects);
        
    }

    //describes and object as concisely as possible in the context. Expects the object in the context as well.
    export function describeInContext (thisObject:ObjectDefinition, context:ObjectDefinition[]):string{
        var sameKind : ObjectDefinition[] = [];
        for (var i = 0; i<context.length; i++){
            if (thisObject.form==context[i].form)
                sameKind.push(context[i]);
        }
        //if it is the only one of its kind, this is enough
        if (sameKind.length==1) return thisObject.form;
        //check if colour makes this a sufficient description
        var same : ObjectDefinition[] = [];
        for (var i = 0; i<sameKind.length; i++){
            if (thisObject.color==context[i].color)
                same.push(context[i]);
        }
        //if it is the only one of its colour, this is enough
        if (same.length==1) return thisObject.color + " " + thisObject.form;
        //Do the same for size

        same = [];
        for (var i = 0; i<sameKind.length; i++){
            if (thisObject.size==context[i].size)
                same.push(context[i]);
        }
        //if it is the only one of its size, this is enough
        if (same.length==1) return thisObject.size + " " + thisObject.form;
        
        //otherwise, return the whole description
        return thisObject.size + " " + thisObject.color + " " + thisObject.form;
    }

}
